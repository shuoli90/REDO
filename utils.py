import json
import time
import typing
from typing import Optional
import re
from collections import defaultdict, deque
from dataclasses import dataclass
from difflib import unified_diff
from xml.etree import ElementTree
from pathlib import Path
from typing import Any, Dict, List, Set, Tuple, Union

import anthropic
from anthropic import Anthropic
from diskcache import Cache

# All calls to Bedrock or the Anthropic API are cached to prevent unnecessary API calls
cache = Cache("~/.cache/birds_transforms-utils_anthropic", size_limit=1e12)


@typing.no_type_check
# @cache.memoize()
def prompt_anthropic(
    prompt: str,
    system: str,
    model_id: str,
    temperature: float = 0,
    **kwargs,
) -> str:
    """Sends a prompt to an Anthropic AI model and retrieves the generated response.

    This function abstracts the complexity of interacting with different versions of
    Anthropic AI models. It handles errors gracefully, retrying as necessary, and logs
    warnings for recoverable errors.

    Args:
        prompt (str): The prompt to send to the LLM.
        system (str): The system prompt to be passed to the LLM. The Q system prompt is
            automatically prepended to this string.
        model_id (str): The identifier of the Anthropic AI model to use.

    Returns:
        str: The text generated by the Anthropic AI model in response to the prompt.

    Raises:
        Exception: If an unrecoverable error occurs after the retry logic has been exhausted.
    """
    system = (Q_SYSTEM_PROMPT + "\n" + system).strip()

    # TODO: Remove this if logic once Opus is added to Bedrock with enough capacity
    if not model_id.startswith("anthropic."):
        if not ANTHROPIC_API_KEY:
            raise ValueError("ANTHROPIC_API_KEY is not set")
        client = Anthropic(api_key=ANTHROPIC_API_KEY)

        response = client.messages.create(
            max_tokens=4096,
            system=system,
            messages=[{"role": "user", "content": prompt}],
            model=model_id,
            temperature=temperature,
            **kwargs,
        )
        result = response.content[0].text
        time.sleep(30)
    else:
        client = boto3.client(
            "bedrock-runtime",
            config=Config(read_timeout=300, retries={"max_attempts": 10, "mode": "standard"}),
        )
        response = client.invoke_model(
            modelId=model_id,
            accept="application/json",
            contentType="application/json",
            body=json.dumps(
                {
                    "anthropic_version": "bedrock-2023-05-31",
                    "max_tokens": 10000,
                    "system": system,
                    "messages": [{"role": "user", "content": [{"type": "text", "text": prompt}]}],
                    "temperature": temperature,
                    **kwargs,
                }
            ),
        )
        if "anthropic.claude-3-opus" in model_id:
            time.sleep(20)
        result = json.loads(response["body"].read())["content"][0]["text"]

    return result

def extract_tag_list(tag: str, text: str, remove_leading_newline: bool = False) -> List[str]:
    """Extract a list of tags from a given XML string.

    Args:
        tag: The XML tag to extract.
        text: The XML string.
        remove_leading_newline: Whether to remove the leading newline from the extracted values.

    Returns:
        A list of values extracted from the provided tag.
    """
    # Define a regular expression pattern to match the tag
    pattern = rf"<{tag}(?:\s+[^>]*)?>(.*?)</{tag}>"

    # Use re.findall to extract all occurrences of the tag
    values = re.findall(pattern, text, re.DOTALL)

    if len(values) == 0:
        pattern = rf"<{tag}(?:\s+[^>]*)?>(.*)"
        values = re.findall(pattern, text, re.DOTALL)
        if len(values) > 0:
            logger.warning(f"'{tag}' tag was found, but had no closing tag.")
        else:
            logger.warning(f"'{tag}' tag was not found.")

    if remove_leading_newline:
        values = [v[1:] if v[0] == "\n" else v for v in values]
    return values

def find_functions_and_classes(filepath):
    with open(filepath, "r") as file:
        tree = ast.parse(file.read(), filename=filepath)
    
    functions_and_classes = []
    
    for node in ast.walk(tree):
        if isinstance(node, (ast.FunctionDef, ast.ClassDef)):
            start_lineno = node.lineno
            end_lineno = None
            for child in ast.walk(node):
                if hasattr(child, 'lineno'):
                    end_lineno = max(end_lineno or 0, child.lineno)
            functions_and_classes.append({
                "name": node.name,
                "type": "class" if isinstance(node, ast.ClassDef) else "function",
                "start_lineno": start_lineno,
                "end_lineno": end_lineno
            })
    
    return functions_and_classes

def extract_code_block(filepath, start_lineno, end_lineno):
    with open(filepath, "r") as file:
        lines = file.readlines()
        code_block = ''.join(lines[start_lineno-1:end_lineno])
    return code_block

def find_functions_and_classes(filepath):
    with open(filepath, "r") as file:
        tree = ast.parse(file.read(), filename=filepath)
    
    functions_and_classes = []
    
    for node in ast.walk(tree):
        if isinstance(node, (ast.FunctionDef, ast.ClassDef)):
            start_lineno = node.lineno
            end_lineno = None
            for child in ast.walk(node):
                if hasattr(child, 'lineno'):
                    end_lineno = max(end_lineno or 0, child.lineno)
            functions_and_classes.append({
                "name": node.name,
                "type": "class" if isinstance(node, ast.ClassDef) else "function",
                "start_lineno": start_lineno,
                "end_lineno": end_lineno
            })
    
    return functions_and_classes

def extract_code_block(filepath, start_lineno, end_lineno):
    with open(filepath, "r") as file:
        lines = file.readlines()
        code_block = ''.join(lines[start_lineno-1:end_lineno])
    return code_block

def identify_code_location(filepath, line_ranges, item_type='function'):
    functions_and_classes = find_functions_and_classes(filepath)
    
    code_locations = []
    for start_line, end_line in line_ranges:
        relevant_items = []
        for item in functions_and_classes:
            if item['type'] == item_type and ((item["start_lineno"] <= start_line <= (item["end_lineno"] or float('inf'))) or \
               (item["start_lineno"] <= end_line <= (item["end_lineno"] or float('inf'))) or \
               (start_line <= item["start_lineno"] and end_line >= item["end_lineno"])):
                relevant_items.append(item)

        if relevant_items:
            largest_item = max(relevant_items, key=lambda x: x["end_lineno"] - x["start_lineno"])
            code_block = extract_code_block(filepath, largest_item["start_lineno"], largest_item["end_lineno"])
            code_locations.append({
                "line_range": (start_line, end_line),
                "location": {
                    "name": largest_item["name"],
                    "type": largest_item["type"],
                    "file": filepath,
                    "start_lineno": largest_item["start_lineno"],
                    "end_lineno": largest_item["end_lineno"],
                    "code_block": code_block
                }
            })
    return code_locations
 
def find_intervals(line_numbers):
    if not line_numbers:
        return []

    # Sort the list of line numbers
    line_numbers.sort()

    # Initialize the list to hold the intervals
    intervals = []

    # Start with the first line number
    start = line_numbers[0]
    end = line_numbers[0]

    for i in range(1, len(line_numbers)):
        if line_numbers[i] == end + 1:
            # If the current line number is continuous, update the end
            end = line_numbers[i]
        else:
            # If not continuous, add the current interval and start a new one
            intervals.append((start, end))
            start = line_numbers[i]
            end = line_numbers[i]

    # Add the last interval
    intervals.append((start, end))

    return intervals